\documentclass[10pt,a4paper]{article}
\usepackage[paper=a4paper,hmargin=0.5cm,bottom=1.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{xargs}
\usepackage{xspace}
\usepackage{caratula}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef,aed2-diseno}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage{graphicx}
\usepackage{graphicx} 
\graphicspath{ {./images/} }
\usepackage[rightcaption]{sidecap}
\usepackage{wrapfig}

\materia{Algoritmos y Estructuras de Datos II}
\titulo{Apunte examen final}
\subtitulo{Segundo cuatrimestre 2021}
\integrante{Ezequiel Rueda Sanchez}{522/16}{ezequiel.ruedasanchez@gmail.com}

%  ü, é, á, í, ó, ú, ñ, Ñ%


\begin{document}

\maketitle

\section{Clase Teórica 01. Especificación I}

\subsection{Introducción}

Típicamente, nos enfrentamos a la siguiente situación. Tenemos un $problema$ que no es presentado en una manera difusa, vaga y se pretende que lo podamos resolver a traves de una computadora de forma eficiente. Lo problematico es transitar este recorrido que va desde la definición informal del problema a su resolución computacional. Este camino tiene una serie de pasos que los llamamos \textbf{especificación}, \textbf{diseño} e \textbf{implementación}. 

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.7\textwidth]{etapas-res-problem}
%	\caption{Etapas en la resolucion de un problema}
%	\label{drivers1}
%\end{figure}

\subsection{Contexto}

Un \textbf{algoritmo} es un procedimiento para resolver un problema, descripto por una secuencia ordenada y finita de pasos bien determinados que nos llevan de un estado inicial a uno final.
\newline
\newline
Ahora bien, el algoritmo, más alla de ser un objeto en si mismo, es una herramienta para resolver problemas donde los más complejos se van a resolver combinando parte de ellos y se van a poder modificar para resolver distintas variantes o \textbf{problemas genéricos}.   
\newline
\newline
Entonces, ¿Qué es resolver un problema \textit{genérico}?
\newline
\newline
Se trata de, dada su descripción, proponer un algoritmo que resuelva cualquier instancia del mismo. Por ejemplo, no proponer un algoritmo que resuelva la suma de 7 y 5 sino proponer un algoritmo que resuelva la suma de dos números enteros cualesquiera.  
\newline
\newline
Para ello, necesitamos herramientas que nos ayuden a transitar el camino desde el enunciado informal hasta la implementación en la computadora. Sobre ello vamos a trabajar a lo largo del curso.

\subsection{Resolución de problemas}

El dueño de un restaurant quiere asegurarse de que los pedidos sean atendidos con prolijidad. Los mozos llevan los pedidos hasta la cocina donde los colocan. Cuando el cocinero se libera, saca el primer pedido y prepara el plato indicado. El dueño quiere saber cuál es el próximo plato a preparar, cuántos pedidos atiende el cocinero cada día y cuál fue el día con menos pedidos.
\newline
\newline
No parece que el problema se pueda expresar directamente en un lenguaje matemático, pero está claro que necesitamos algo riguroso y formal para poder pasar al algoritmo. 
\newline
\newline
Sin embargo, podemos observar que se pretenden obtener resultados de varios tipos distintos: al menos naturales (los dias que pasan) y platos. Además, hay varias operaciones asociadas a estos tipos.
\newline
\newline
Para poder modelar este problema, vamos a usar una herramienta nueva: \textbf{Tipos Abstracto de Datos (TAD)}. Veamos un poco más en detalle este concepto.
\newline
\newline
\textbf{.} Tipo: conjunto de valores asociados a operaciones
\newline
\newline
\textbf{.} Tipo abstracto: no nos interesa tanto "la forma" de los valores sino saber que operaciones podemos realizar sobre ellos donde la única manera de obtener información sobre ellos es a través de las operaciones que definan.
\newline
\newline
El problema maneja platos, dias y (al menos un) restaurant.
\newline
\newline
¿Qué nos interesa saber de cada una de estas $"$cosas$"$?
\newline
\newline
\textbf{.} Los dias pasan por lo que vamos a querer contarlos.
\newline
\newline
\textbf{.} Solo nos interesa poder diferenciar los platos entre si.
\newline
\newline
\textbf{.} De los restaurants, varias cosas, asi que lo dejamos de lado por un momento.
\newpage
Comenzamos usando renombres:
\newline
\newline
\textbf{.} TAD \tadNombre{DIA} es \tadNombre{NAT}  
\newline
\newline
\textbf{.} TAD \tadNombre{PLATO} es \tadNombre{STRING}.
\newline
\newline
¿Por qué tenemos que renombrar estos TADs y no utilizar STRING o NAT directamente? Lo que queriamos hacer era utilizar un lenguaje de especificación que nos permita abstraer ciertos conceptos, por lo que usar STRING directamente no sería correcto. Para el restaurant no tiene sentido un STRING, pero los PLATOS si. De esta manera, nos alejamos de la manera en la que representamos los datos en una computadora y nos acercamos a la definición del problema.
\newline
\newline
Pasemos ahora al restaurant...
\newline
\begin{tad}{\tadNombre{Restaurant}}
	\medskip	
	\textbf{generos} restaurant
	\newline
	
	\textbf{operaciones}
	\medskip
	\tadOperacion{inaugurar}{}{restaurant}{}
	\medskip
	\tadOperacion{cantPlatosPendientes}{restaurant}{nat}{}
	\medskip
	\tadOperacion{proximoPedido}{restaurant/r}{plato}{cantPlatosPendientes($r$) $>$ 0}
	\medskip
	\tadOperacion{prepararPlato}{restaurant/r}{restaurant}{cantPlatosPendientes($r$) $>$ 0}
	\medskip
	\tadOperacion{tomarPedido}{restaurant, plato}{restaurant}{}
	\medskip
	\tadOperacion{nuevoDia}{restaurant}{restaurant}{}
	\medskip
	\tadOperacion{diaActual}{restaurant}{dia}{}
	\medskip
	\tadOperacion{platosPorDia}{restaurant/r, dia/d}{nat}{$d$ $\leq$ diaActual($r$)}
	\medskip
	\tadOperacion{diaMenosPedidos}{restaurant}{dia}{}
	\medskip
\end{tad}
\medskip
A esto lo llamamos \textbf{signatura} del TAD. La signatura nos indica que operaciones tiene el tipo, con qué parámetros y qué devuelven.
\newline
\newline
Las operaciones de los TAD's son \textit{funciones totales}. O sea, funciones que están definidas para cada valor del dominio. Por eso, en casos como \TipoVariable{preparar\_plato()} debemos restringir el dominio.
\newline
\newline
Ahora, necesitamos darle \textbf{semántica}, es decir, comportamiento a las operaciones. En los TADs usaremos para eso los \textbf{axiomas}.
\newline
\newline
Entonces, veamos los axiomas del TAD \tadNombre{RESTAURANT}.
\newline
\begin{tad}{\tadNombre{Restaurant}}
\medskip
\tadAxiomas[$\forall$ $r$ : \tadNombre{Restaurant}, $p$ : \tadNombre{Plato}, $d$ : \tadNombre{Dia}]
\medskip
\tadAlinearAxiomas{diaActual(tomarPedido(r,p))}
\medskip
\tadAxioma{diaActual(inaugurar())}{0}
\medskip
\tadAxioma{diaActual(nuevoDia(r))}{diaActual(r)+1}
\medskip
\tadAxioma{diaActual(tomarPedido(r,p))}{diaActual(r)}
\medskip
\medskip

\tadAlinearAxiomas{cantPlatosPendientes(tomarPedido(r,p))}
\medskip
\tadAxioma{cantPlatosPendientes(inaugurar())}{0}
\medskip
\tadAxioma{cantPlatosPendientes(tomarPedido(r,p))}{cantPlatosPendientes(r)+1}
\medskip
\tadAxioma{cantPlatosPendientes(prepararPlato(r))}{cantPlatosPendientes(r)-1}
\medskip
\medskip

\tadAlinearAxiomas{cantPlatosPendientes(tomarPedido(r,p))}
\medskip
\tadAxioma{proximoPedido(r)}{ult(secuenciaDePedidos(r))}
\medskip
\medskip

\tadAlinearAxiomas{secuenciaDePedidos(tomarPedido(r,p))}
\medskip
\tadAxioma{secuenciaDePedidos(inaugurar())}{$\secuvacia$}
\medskip
\tadAxioma{secuenciaDePedidos(tomarPedido(r,p))}{p $\puntito$ secuenciaDePedidos(r)}
\medskip
\tadAxioma{secuenciaDePedidos(prepararPlato(r))}{com(secuenciaDePedidos(r))}
\medskip
\medskip

\tadAlinearAxiomas{platosPorDia(d, tomarPedido(r,p))}
\medskip
\tadAxioma{platosPorDia(d, inaugurar())}{0}
\medskip
\tadAxioma{platosPorDia(d, tomarPedido(r,p))}{platosPorDia(d,r)}
\medskip
\tadAxioma{platosPorDia(d, prepararPlato(r))}{\IF diaActual(r) = d THEN platosPorDia(d,r)+1 ELSE platosPorDia(d,r) FI}
\medskip
\tadAxioma{platosPorDia(d, nuevoDia(r))}{\IF diaActual(r)+1 = d THEN 0 ELSE platosPorDia(d,r) FI}
\medskip
\medskip

Por ultimo, vamos a axiomatizar la funcion diaMenosPedidos(r) de la siguiente forma:
\newline
\newline
($\forall$ $d'$:dia) (0 $\leq$ $d'$ $\leq$ diaActual($r$) $\impluego$ platosPorDia($r$, diaMenosPedidos($r$)) $\leq$ platosPorDia($r,d'$))
\medskip
\end{tad}

\subsection{TAD's}

¿Qué es un TAD?
\newline
\newline
\textbf{.} Desde el punto de vista formal, es una herramienta lógico/matematica. Eso es bueno porque nos da la rigurosidad que necesitamos para entender claramente qué hay que hacer.
\newline
\newline
\textbf{.} Desde el punto de vista práctico, es una herramienta poderosa y flexible que nos permite resolver o formalizar infinidad de problemas.
\newline
\newline
\textbf{.} Desde el punto de vista histórico, uno de los primeros intentos por abordar este problema.
\newline
\newline
Una de las ventajas de la teoría de los tipos abstractos de datos es que no requiere de tipos primitivos que deban definirse por fuera de la misma. 

\subsection{Secciones de un TAD}

Las secciones de un TAD son:
\newline
\newline
\textbf{.} Géneros: Los géneros (en general va a haber sólo uno, pero podrían ser más) son el nombre que recibe el conjunto de valores del tipo. Pensar en el monoide conmutativo ($\mathbb{N}$, +) y en el conjunto de los números naturales $\mathbb{N}$. 
\newline
\newline
\textbf{.} Usa: Inclusión de los géneros y operaciones definidos en otros tipos abstractos de datos que utiliza el tipo que estamos definiendo.
\newline
\newline
\textbf{.} Exporta: Qué operaciones y géneros se dejan a disposición de los usuarios del tipo.
\newline
\newline
\textbf{.} Generadores: Son operaciones que permiten construir instancias del tipo. Un conjunto de generadores está bien definido si una combinación de ellos permite construir cualquier instancia posible del tipo.
\newline
\newline
\textbf{.} Observadores: Son operaciones que nos permiten, utilizadas en conjunto, diferenciar instancias del tipo.
\newline
\newline
\textbf{.} Axiomas: Son las reglas que nos explican el comportamiento de las funciones o describen el comportamiento desde el punto de vista semántico de un objeto del TAD. 
\newpage

\section{Clase Teórica 02. Especificación II}

\subsection{Introducción}

La especificación con TADs no es la única forma de hacerlo.
\newline
\newline
Siempre es posible la utilización de \textit{métodos informales}
\newline
\newline
Los métodos informales tienen un menor costo inicial (son mas fáciles de construir y utilizar) pero justamente por ello, no permiten encontrar errores e inconsistencias en la especificación, ni la aplicación de técnicas automáticas para la validación (en contraposición a los métodos formales con la inducción estructural por ejemplo), etc.
\newline
\newline
El costo de reparar un defecto aumenta con el tiempo entre la introducción y el descubrimiento.
\newline
\newline
En cambio, los \textit{métodos formales} no cuentan con esos problemas pero existen de variado tipo y color con ventajas y desventajas para cada caso. Veamos alguno de ellos:
\newline
\newline
\textbf{.} Algebraicos: el sistema se especifica mediante la definición de un álgebra con sus términos, operaciones, axiomas, etc. Los TADs entran en esta categoría.
\newline
\newline
\textbf{.} Operacionales: la especificación se realiza en un lenguaje imperativo de alto nivel.
\newline
\newline
\textbf{.} Basados en estados: el sistema se modela como un conjunto de estados posibles y las relaciones entre ellos. 

\subsection{Resolución de problemas}

Retomando el ejercicio del \textit{restaurant}, comenzamos con una descripción del problema y terminamos con el modelao del mismo. 
\newline
\newline
Pero, ¿Qué ocurrió en el medio?
\newline
\newline
¿Qué pasó con, por ejemplo, el dueño del restaurant? 
\newline
\newline
El dueño no está porque no es necesario que esté. Utilizamos un proceso llamado \textbf{abstracción}. La abstracción consiste en identificar los aspectos importantes de un fenomeno e ignorar el resto de los detalles.
\newline
\newline
También utilizamos otro concepto: el de \textbf{modularidad}. Los TADs se incluyen de manera tal que no sea necesario (ni conveniente) escribir una gran especificación que mezcle todo y dificulte la comprensión. 
\newline
\newline
El restaurant que especificamos, ¿es eficiente?
\newline
\newline
La pregunta no tiene sentido en una etapa de especificación porque justamente la especificación define que es lo que tenemos que computar, que es lo que tenemos que calcular para resolver nuestro problema y no como lo vamos a hacer. 
\newline
\newline
Nos interesa describir el \textbf{el qué} y no \textbf{el cómo}.

\subsection{Axiomatización}

Las operaciones son funciones, asi que debemos evitar inconsistencias. Para lograr esto, evitaremos la \textbf{sobre especificación}. Es decir, cuando tenemos varias formas de decir lo mismo.
\newline
\newline
Veamos la \textit{sobre especificación} con un ejemplo.
\newline
\newline
\textbf{.} \TipoVariable{prim\_excepto\_3(3 $\puntito$ S)} $\equiv$ 21
\newline
\newline
\textbf{.} \TipoVariable{prim\_excepto\_3(a $\puntito$ S)} $\equiv$ a
\newline
\newline
En este ejemplo, quiero devolver el primer elemento de la secuencia \TipoVariable{S} excepto que cuando el primer elemento es un 3, devuelvo cualquier número arbitrario, por ejemplo, el 21. 
\newline
\newline
Observemos que estamos haciendo una especie de \textit{pattern matching} porque si la secuencia comienza con 3, elijo la primer opción y en cualquier otro caso, la segunda. Pero tenemos valores contradictorios en el caso que el primer elemento de la secuencia sea el 3 porque nada nos asegura que vaya por la primer o segunda opción.
\newline
\newline
Tampoco podemos especificar sobre los casos restringidos ya que están fuera del dominio.
\newline
\newline
No debemos \textbf{subespecificar}. Es decir, dejar de lado y no dar definiciones precisas de ciertos aspectos particulares de un determinado axioma. Veamos el siguiente ejemplo.
\newline
\tadOperacion{premiar}{torneo/t, jugador/j}{premio}{}
\medskip
\tadAlinearAxiomas{premiar(t,j)}
\medskip
\tadAxioma{premiar(t,j)}{seleccionarMejorPremio(premiosDisponibles(t))}
\medskip
\tadAxioma{premiar(t,j)}{dameUno(premiosDisponibles(t))}
\medskip
\medskip
Observemos que la segunda axiomatización es mucho más debil (está \textit{subespecificada}) que la primera dado que ésta es mucho mas precisa porque pide el mejor premio mientras que la segunda simplemente devuelve un premio. 
\newline
\newline
Entonces, ¿Hasta cuánto debemos axiomatizar?
\newline
\newline
Una regla práctica consiste en axiomatizar todos los observadores básicos sobre todos los generadores no restringidos, para asegurar que cubrimos todo el dominio.
\newline
\newline
En general, aunque podría haber excepciones, el resto de las operaciones deberían poder escribirse en base a los observadores básicos.

\subsection{Algunas libertades}

Si usamos todo lo que aparece mencionado, no es necesario escribir la clausula \textbf{usa}.
\newline
\newline
El \textbf{exporta} tiene un valor por omisión: los géneros, los observadores básicos y los generadores. Además, cuando se exporta algo más, alcanza con aclarar qué es lo extra que se exporta.
\newline
\newline
En la \textbf{axiomatización}:
\newline
\newline
\textbf{.} Todas las variables libres se suponen universalmente cuantificadas.
\newline
\newline
\textbf{.} Sólo cuantificamos explícitamente cuando podría generarse confusión.

\subsection{Elección de generadores y observadores}

Conviene que el conjunto de observadores y generadores sean \textit{minimales}. 
\newline
\newline
Si los generadores no lo fuesen, se corre el riesgo de producir inconsistencias.
\newline
\newline
Idem con los observadores. Además, la redundancia atenta contra la claridad.
\newline
\newline
Los lenguajes naturales tienen una \textit{semántica difusa} mientras que los \textit{lenguajes formales} de especificación son rigurosos, o dicho de otra manera, tienen una \textit{semántica precisa}. A esta diferencia se la conoce como \textbf{semantic gap} o \textbf{brecha semántica}.
\newline
\newline
Como primer paso para vincular los mundos \textit{informales} con los \textit{formales} utilizaremos una herramienta llamada \textbf{igualdad observacional}.
\newpage

\subsection{Igualdad observacional (como herramienta)}

La igualdad observacional es un predicado entre instancias del tipo que nos dice cuando son iguales (desde el punto de vista de su comportamiento).
\newline
\newline
Notemos que \TipoVariable{Ag(1, Ag(2, $\emptyset$))} es sintácticamente distinto a \TipoVariable{Ag(2, Ag(1, $\emptyset$))} aunque desde el punto de vista de comportamiento nos gustaría que sean iguales. 
\newline
\newline
Entonces, para poder comparar las instancias del ejemplo anterior vamos a utilizar la igualdad observacional que se va a valer de una serie de funciones (los observadores básicos) los cuales van a prestar atención a detalles particulares de esas instancias para poder compararlas.
\newline
\newline
Por lo tanto, la igualdad observacional nos permite:
\newline
\newline
\textbf{.} Deducir cuáles son los observadores necesarios.
\newline
\newline
\textbf{.} Explicitar cómo se combinan en un único predicado.

\subsection{Congruencia}

Imaginemos el TAD \tadNombre{Negocio}.
\newline
\begin{tad}{\tadNombre{Negocio}}
	\medskip	
        \textbf{generadores}
	\medskip
	\tadOperacion{inaugurar}{}{negocio}{}
	\medskip
	\tadOperacion{vender}{negocio, producto}{negocio}{}
	\medskip
        \medskip
        \textbf{observadores basicos}
        \medskip
	\tadOperacion{total\_vendido}{negocio}{nat}{}
	\medskip
        \medskip
        \textbf{otras operaciones}
        \medskip
\tadOperacion{ventas}{negocio}{secu(producto)}{}
	\medskip
\end{tad}
\medskip
\medskip
De acuerdo con esa especificación dos negocios van a ser iguales si su total vendido coincide. Sin embargo, podría haber instancias cuyo total vendido coincida pero la secuencia de productos que devuelve la operación ventas no.
\newline
\newline
Formalmente, la función \TipoVariable{ventas()} rompe la \textbf{congruencia}. Es decir, diferencia elementos que quedan en la misma clase de equivalencia de acuerdo con la igualdad observacional (o lo que es lo mismo, de acuerdo con los observadores básicos).
\newline
\newline
Desde el punto de vista de modelado, o bien desaparece \TipoVariable{ventas()} o bien se vuelve un observador básico, y por ende, miembro de la igualdad observacional.
\newline
\newline
Si no hacemos eso, se genera una \textbf{inconsistencia}: hay dos instancias del TAD \tadNombre{Negocio} que son equivalentes según los observadores básicos, pero que son diferenciables de acuerdo a los axiomas efectivamente escritos. 
\newpage

\section{Clase Teórica 03. Complejidad Algorítmica}

Para resolver problemas, tenemos que diseñar algoritmos y estructuras de datos que sean \textbf{eficientes}  en términos del consumo de recursos.
\newline
\newline
Esa medida de eficiencia nos permitirá elegir entre distintos algoritmos para resolver el mismo problema y distintas formas de implementar un TAD. 
\newline
\newline
¿Cuáles son esos recursos que se consumen?
\newline
\newline
\textbf{.} Tiempo de ejecución
\newline
\newline
\textbf{.} Espacio (memoria)
\newline
\newline
\textbf{.} Cantidad de procesadores (en el caso de algoritmos paralelos)
\newline
\newline
\textbf{.} Utilización de la red de comunicaciones (para algoritmos paralelos).
\newline
\newline
Nos vamos a ocupar de los primeros dos criterios: tiempo de ejecución y espacio (memoria).

\subsection{Complejidad Algorítmica}

¿Cómo medimos la complejidad algorítmica? El análisis de la complejidad de un algoritmo se puede hacer a traves de dos enfoques:
\newline
\newline
\textbf{.} Empírica o experimental
\newline
\newline
Medir el tiempo de ejecución para una determinada entrada y en una computadora concreta
\newline
\newline
Usando un cronómetro, o analizando el consumo de recursos de la computadora (tiempo de CPU)
\newline
\newline
Medidas del tipo: 3GB, 1.5 segundos.
\newline
\newline
\textbf{.} Teórica
\newline
\newline
Medida teórica del comportamiento de un algoritmo. Es decir, la idea es poder calcular la complejidad a priori, intuir, poder estimar lo que va a tardar la complejidad de un algoritmo antes de ejecutarlo.
\newline
\newline
Uno de los problemas que tiene el análisis empírico sobre el teórico es que medir el tiempo de ejecución me puede insumir mucho tiempo en realizarlo. Además, el análisis empírico cambia de computadora en computadora y otro problema es que el contexto de uso puede cambiar mucho el tiempo real de ejecución. Si estoy ejecutando el algoritmo en un sistema multitasking y demoró una cierta cantidad de tiempo, no implica que va a tardar lo mismo en un entorno con muchos más usuarios logeados, problemas en la conexión de la red o cualquier factor externo pero que influye en la performance de mi equipo.

\subsection{Ventajas del enfoque teórico}

Las ventajas del enfoque teórico son:
\newline
\newline
\textbf{.} El análisis se puede hacer a priori, aún antes de escribir una linea de código.
\newline
\newline
\textbf{.} Vale para todas las instancias del problema
\newline
\newline
\textbf{.} Es independiente de la máquina en la que se ejecuta
\newline
\newline
\textbf{.} Es independiente de la pericia del programador
\newpage

\subsection{Análisis teórico}

La medida de complejidad está asociada a un $"$módelo de máquina$"$ o $"$módelo de cómputo$"$ consensuado.
\newline
\newline
Para medir todas las instancias posibles, no vamos a hablar de instancias particulares sino de tamaño de las instancias. Vamos a dar una medida de complejidad en función del \textit{input} de las instancias. 
\newline
\newline
Puede suceder que no todas las instancias del mismo tamaño consuman la memoria de la misma manera. Entonces, para esos casos, vamos a ver complejidad para distintos tipos de inputs. 
\newline
\newline
Vamos a realizar \textit{análisis asintòtico}. Nos vamos a enfocar en el tiempo de ejecución de instancias grandes.

\subsubsection{Modelo cómputo}

Queremos una medida \textit{universal} válida para distintas implementaciones del algoritmo.
\newline
\newline
Por lo tanto, vamos a inventar una máquina teórica que vamos a utilizar como banco de pruebas para la ejecución del algoritmo. 
\newline
\newline
En esta definición de máquina, vamos a poder tomar una \textbf{medida del tiempo}: número de pasos o instrucciones que se ejecutan en esa máquina \textit{ideal} para determinado \textit{input}.
\newline
\newline
En esta definición de máquina, vamos a poder tomar una \textbf{medida del espacio}: número de posiciones de memoria en esa máquina \textit{ideal} que se utilizan para determiando \textit{input}.
\newline
\newline
\textbf{Operaciones elementales}
\newline
\newline
Las operaciones elementales son aquellas operaciones que tardan una unidad de tiempo en el modelo de máquina que estoy definiendo.
\newline
\newline
Vamos a utilizar una función de complejidad \textit{t(I)} que mide el número de operaciones elementales requeridas para la instancia \textit{I}.
\newline
\newline
Las operaciones elementales (OE) serán aquellas que el procesador realiza en tiempo acotado por una constante (que no depende del tamaño de la entrada).
\newline
\newline
Consideramos OE las operaciones aritméticas básicas, comparaciones lógicas, transferencias de control, asignaciones a variables de tipos básicos, etc (tener cuidado; para ello es importante definir bien el modelo de cómputo y cuáles son las operaciones elementales).
\newline
\newline
\textbf{Cálculo de Operaciones Elementales}
\newline
\newline
\textbf{.} Vamos a considerar que el tiempo de una OE es, por definición, 1.
\newline
\newline
\textbf{.} El tiempo de ejecución de una secuencia consecutiva de instrucciones se calcula sumando los tiempos de ejecución de cada una de las instrucciones.
\newline
\newline
\textbf{Ejemplo}.

\begin{algorithm}[H]{i\tadNombre{busquedaSecuencial}(\In{A}{array(T)}, \In{x}{T})}
	\begin{algorithmic}[1]
		\State $i$ $\gets$ 1
            \State $encontre$ $\gets$ $false$
            \While{$!encontre$}
		\If{$A[i] = x$}
		\State $encontre$ $\gets$ $true$                 
		\State $i$ $\gets$ $i+1$         \EndIf
            \EndWhile
            \State $print(i-1)$ 
		
		\medskip
	\end{algorithmic}
\end{algorithm}
\newpage

¿Cuánto tarda la ejecución de $Buscar(5, [2,6,3,5,8])$?
\newline
\newline
Para resolver esto, tenemos que contar cuantas operaciones elementales se ejecutan entre que empieza el algoritmo y termina con una respuesta. 
\newline
\newline
Comienza el algoritmo y se realiza la asignación $i$ $\gets$ 1 (1OE). Luego, se realiza la asignación $encontre$ $\gets$ $false$ (1OE).
\newline
\newline
En la instrucción \textbf{while} $!encontre$, tenemos una negación y una comparación (2OE). 
\newline
\newline
Luego, en la instrucción \textbf{if} $A[i] = x$ tenemos 1OE para acceeder a la variable $x$, otra OE para compararlo con $A[i]$. Ahora, como 5 != 2, no accedo a la linea de $encontre$ $\gets$ $true$ pero si a la de $i$ $\gets$ $i+1$ que hay 3OE, 1 para el acceso de la variable $i$, otra para la suma de esta y una última para el salto al ciclo \textbf{while} nuevamente. 
\newline
\newline
Analogamente al caso anterior porque 6 != 5, tenemos 2OE con respecto a la instrucción \textbf{while} $!encontre$, 2OE con respecto a la instrucción \textbf{if} $A[i] = x$ y 3OE con respecto a la instrucción $i$ $\gets$ $i+1$. 
\newline
\newline
Del mismo modo como 3 != 5, , tenemos 2OE con respecto a la instrucción \textbf{while} $!encontre$, 2OE con respecto a la instrucción \textbf{if} $A[i] = x$ y 3OE con respecto a la instrucción $i$ $\gets$ $i+1$.
\newline
\newline
Ahora, como 5 = 5, tenemos 2OE con respecto a la instrucción \textbf{while} $!encontre$, 4OE con respecto a la instrucción \textbf{if} $A[i] = x$ (las dos que teniamos en los casos anteriores pero ahora sumamos 1OE de la asignación $encontre$ $\gets$ $true$ y 1OE del salto del ciclo a la instrucción $print(i-1)$) y 1OE con respecto a la ejecución de $print(i-1)$.
\newline
\newline
Por lo tanto, podemos concluir que la ejecución de  $Buscar(5, [2,6,3,5,8])$ tarda 30 Operaciones Elementales. 
\newline
\newline
\textbf{Reglas generales (pensando en análisis del caso peor)}
\newline
\newline
\textbf{.} El tiempo de ejecución de la sentencia \TipoVariable{CASE C OF $v_{1}$:$S_{1}$|$v_{2}$:$S_{2}$|...|$v_{n}$:$S_{n}$ END} es \TipoVariable{T = T(C) + max\{T($S_{1}$),T($S_{2}$),...,T($S_{n}$)\}}. Observemos que T(C) incluye el tiempo de comparación con $v_{1}$,$v_{2}$,...,$v_{n}$.
\newline
\newline
\textbf{.} El tiempo de ejecución de la sentencia \TipoVariable{IF C THEN $S_{1}$ ELSE $S_{2}$ END} es \TipoVariable{T = T(C) + max\{T($S_{1}$),T($S_{2}$)\}}
\newline
\newline
\textbf{.} El tiempo de ejecución de un bucle de sentencias \TipoVariable{WHILE C DO S END} es \TipoVariable{T = T(C) + (nº iteraciones) * (T(S) + T(C))}. Observemos que tanto T(C) como T(S) pueden variar en cada iteración, y por lo tanto, habrá que tenerlo en cuenta para su cálculo.   
\newline
\newline
\textbf{.} Para calcular el tiempo de ejecución del resto de las sentencias iterativas (\TipoVariable{FOR}, \TipoVariable{REPEAT}, \TipoVariable{LOOP}) basta expresarlas como un bucle \TipoVariable{WHILE}.
\newline
\newline
\textbf{.} El tiempo de ejecución de una llamada a un procedimiento o función \TipoVariable{F($P_{1}$,$P_{2}$,...,$P_{n}$)} es 1 por llamada más el tiempo de evaluación de los parámetros $P_{1}$,$P_{2}$,...,$P_{n}$ más el tiempo que tarde en ejecutarse \TipoVariable{F}, esto es \TipoVariable{T = 1 + T($P_{1}$) + T($P_{2}$) + ... + T($P_{n}$) + T(F)}. No contabilizamos la copia de los argumentos a la pila de ejecución, salvo que se trate de estructuras complejas (registros o vectores) que se pasan por valor. En este caso, contabilizaremos tantas OE como valores simples contenga la estructura. El paso de parámetros por referencia, por tratarse simplemente de punteros, no contabiliza tampoco. 

\subsubsection{Tamaño de la entrada}

Queremos una complejidad relativa, no absoluta. El tamaño de la entrada es una medida general de lo que podemos encontrarnos al ejecutar (queremos predecir, no nos interesa cuanto tarda para una instancia particular sino para clases de instancias).
\newline
\newline
Entonces, presentamos la notación que vamos a utilizar:
\newline
\newline
\textbf{.} \textbf{\textit{T(n)}}: complejidad temporal (o en tiempo) para una entrada de tamaño \textit{n}.
\newline
\newline
\textbf{.} \textbf{\textit{S(n)}}: complejidad espacial para una entrada de tamaño \textit{n}.
\newline
\newline
Entonces, como vamos a medir en función del tamaño del input, tenemos que considerar distintas instancias porque, aunque tengan el mismo tamaño, puede hacer que el algoritmo se comporte de maneras muy diferentes, y por lo tanto, tomar distinto tiempo, y/o requerir distinta cantidad de memoria.
\newline
\newline
Así suelen estudiarse tres casos para un mismo algoritmo: \textbf{caso peor}, \textbf{caso mejor} y \textbf{caso medio}.
\newline
\newline
\textbf{Análisis del caso peor}
\newline
\newline
Sea $t(i)$ el tiempo de ejecución de un algoritmo sobre una instancia $i$.
\newline
\newline
$T_{peor}(n)$ = $max_{instancias~i,~|i|=n}$$\{t(i)\}$
\newline
\newline
Intuitivamente, $T_{peor}(n)$ es el tiempo de ejecución del algoritmo sobre la instancia que implica mayor tiempo de ejecución (entre los inputs de tamaño $n$).
\newline
\newline
Este análisis da \textbf{garantías} sobre las prestaciones del algoritmo.
\newline
\newline
\textbf{Análisis del caso mejor}
\newline
\newline
$T_{mejor}(n)$ = $min_{instancias~i,~|i|=n}$$\{t(i)\}$
\newline
\newline
Intuitivamente, $T_{mejor}(n)$ es el tiempo de ejecución del algoritmo sobre la instancia que implica menor tiempo de ejecución (entre los inputs de tamaño $n$).
\newline
\newline
No da mucha información.
\newline
\newline
\textbf{Análisis del caso medio o promedio}
\newline
\newline
Intuitivamente, $T_{prom}(n)$ corresponde al tiempo \textit{promedio} de ejecución, al tiempo \textit{esperado} sobre instancias \textit{típicas}.
\newline
\newline
Se define como la esperanza matemática de la variable aleatoria definida por todas las posibles ejecuciones del algoritmo para un tamaño de la entrada dado, con las probabilidades de que éstas ocurran para esa entrada.
\newline
\newline
Sea $P(i)$ la probabilidad de que el input sea la instancia $i$.
\newline
\newline
Por lo tanto, $T_{prom}(n)$ = $\displaystyle \sum_{instancias~i,~|i|=n}^{}$$\{P(i)~t(i)\}$
\newline
\newline
Volvamos al ejemplo de búsqueda secuencial.
\newline
\begin{algorithm}[H]{i\tadNombre{busquedaSecuencial}(\In{A}{array(T)}, \In{x}{T})}
	\begin{algorithmic}[1]
		\State $i$ $\gets$ 1
            \State $encontre$ $\gets$ $false$
            \While{$!encontre$}
		\If{$A[i] = x$}
		\State $encontre$ $\gets$ $true$                 
		\State $i$ $\gets$ $i+1$         \EndIf
            \EndWhile
            \State $print(i-1)$ 
		
		\medskip
	\end{algorithmic}
\end{algorithm}
\medskip
Entonces, ahora queremos calcular $T_{peor}(n)$, $T_{mejor}(n)$ y $T_{prom}(n)$.
\newline
\newline
En el peor caso, podemos decir que el elemento se va a encontrar al final del arreglo. Por lo tanto, para las $n-1$ iteraciones anteriores tenemos 5 instruccciones en cada iteración y en el caso de la iteracion $n$ donde se encuentra el elemento buscado, tenemos 6 instrucciones. Ademas, de las 2 instrucciones correspondientes a las primeras dos lineas del algoritmo. Por lo tanto, tenemos que $T_{peor}(n)$ = $2 + 5(n-1) + 6$ = $8 + 5(n-1)$
\newline
\newline
\newline
En el mejor caso, podemos decir que el elemento se va a encontrar en la primera posición del arreglo. Por lo tanto, tenemos que $T_{mejor}(n)$ = $9$
\newline
\newline
En el caso promedio, tendriamos que suponer que alguna hipotesis sobre como está distribuido el input. Es decir, que probabilidad hay de que el elemento buscado esté en la primer posición, que probabilidad hay de que el elemento buscado esté en la segunda posición, que probabilidad hay de que el elemento buscado esté en la tercer posición, etc. Si suponemos que es equiprobable que esté en cualquier posición, vamos a tener un costo para las primeras operaciones y un valor esperado que se encuentre en la posición $\displaystyle \frac{n}{2}$ porque todas las posiciones son equiprobables. Por lo tanto, tenemos aproximadamente que $T_{prom}(n)$ = $8 + 5$ $\displaystyle \frac{n}{2}$
\newline
\newline
¿Cuánto tarda la búsqueda secuencial si el arreglo está ordenado?
\newline
\newline
El algoritmo de búsqueda secuencial tarda lo mismo si el arreglo está ordenado en los tres análisis.
\newline
\newline
¿Cuánto tarda la búsqueda binaria?
\newline
\newline
En este caso, si se producen diferencias porque el ciclo de la búsqueda binaria se ejecuta una cantidad de veces que es logaritmica en $n$ y no una cantidad de veces que es lineal en $n$ como en la búsqueda secuencial.
\newline
\newline
Ahora, para calcular el costo espacial, necesitamos 3 espacios de memorias para almacenar las variables $i$, $encontre$ y la variable $x$ correspondiente al elemento que estamos buscando. Además, necesitamos tambien $n$ espacios en memoria correspondiente al tamaño del arreglo ($n$). Por lo tanto, $S(n)$ = $n+3$. 

\subsubsection{Principio de invarianza}

Dado un algoritmo y dos máquinas (o dos implementaciones) $M_{1}$ y $M_{2}$ que tardan $T_{1}(n)$ y $T_{2}(n)$ respectivamente sobre inputs de tamaño $n$, existe una constante real $c > 0$ y un $n_{0} \in \mathbb{N}$ tales que $\forall$ $n \geq n_{0}$ se verifica que $T_{1}(n)$ $\leq$ $c$ . $T_{2}(n)$  
\newline
\newline
Es decir, que dos ejecuciones distintas del mismo algoritmo sólo difieren en cuanto a eficiencia en un factor constante para grandes valores de la entradas suficientemente grandes.
\newline
\newline
Como \textbf{consecuencia} de esto, no necesitamos usar ninguna unidad para medir el tiempo.

\subsubsection{Análisis asintótico}

Ahora, nos va a interesar calcular, de forma aproximada, el \textbf{orden de magnitud} que tiene el \textbf{tiempo de ejecución} de cada algoritmo.
\newline
\newline
Cuando el tamaño de los datos es pequeño no habrá diferencias significativas en el uso de los distintos algoritmos. 
\newline
\newline
Cuando el tamaño de los datos es \textbf{grande}, los \textbf{costos} de los diferentes algoritmos si pueden variar de manera significativa. 
\newline
\newline
El \textbf{orden} (logarítmico, lineal, cuadrático, exponencial, etc) de la función \textbf{\textit{T(n)}} que mide la complejidad temporal de un algoritmo, es el que \textit{expresa el comportamiento dominante cuando el tamaño de la entrada es grande}. 
\newline
\newline
Es decir, el \textbf{comportamiento asintótico}.
\newline
\newline
El objetivo del estudio de la complejidad algorítmica es determinar el comportamiento asintótico de un algoritmo.
\newline
\newline
Para ello, tenemos distintas medidas del comportamiento asintótico de la complejidad:
\newline
\newline
\textbf{.} $O$ ($O$ grande) cota superior. 
\newline
\newline
\textbf{.} $\Omega$ (omega) cota inferior. 
\newline
\newline
\textbf{.} $\Theta$ (theta) orden exacto de la función. 
\newpage
\subsection{Cota superior. Notación \textit{O}}

La notación \textit{O} sirve para representar el límite o cota superior del tiempo de ejecución de un algoritmo.
\newline
\newline
Más precisamente, la notación \textit{f $\in$ O(g)} expresa que la función \textbf{\textit{f} no crece más rapido que alguna función proporcional a \textit{g}}.
\newline
\newline
En este caso, a \textit{g} se la llama cota superior de \textit{f}.
\newline
\newline
Si para un algoritmo sabemos que $T_{peor} \in O(g)$ se puede asegurar que para inputs de tamaño creciente, \textbf{en todos los casos} el tiempo será a lo sumo proporcional a la cota.
\newline
\newline
Si para un algoritmo sabemos que $T_{prom} \in O(g)$ se puede asegurar que para inputs de tamaño creciente, \textbf{en promedio} el tiempo será a lo sumo proporcional a la cota.
\newline
\newline
Veamos más formalmente la notación \textit{O}.
\newline
\newline
Asumiendo funciones reales no negativas con dominio en los naturales:
\newline
\newline
$f \in O(g)$ significa que \textit{f} no crece más que \textit{g}.  
\newline
\newline
$O(g)$ = \{$f$ $|$ $\exists$ $n_{0}$, $k > 0$ tal que $n \geq n_{0}$ $\Rightarrow$ $f(n)$ $\leq$ $k$ · $g(n)$\} 

\subsubsection{Propiedades de \textit{O}}

A continuación, mencionamos algunas propiedades de la notación \textit{O}:
\newline
\newline
1. Para cualquier función $f$ se tiene que $f \in O(f)$.
\newline
\newline
2. $f \in O(f)$ $\Rightarrow$ $O(f)$ $\subset$ $O(g)$. 
\newline
\newline
3. $O(f)$ $=$ $O(g)$ $\Leftrightarrow$ $f \in O(g)$ y $g \in O(f)$
\newline
\newline
4. Si $f \in O(g)$ y $g \in O(h)$ $\Rightarrow$ $f \in O(h)$.
\newline
\newline
5. Si $f \in O(g)$ y $f \in O(h)$ $\Rightarrow$ $f \in O(min(g,h))$. 
\newline
\newline
6. Regla de la suma: Si $f_{1} \in O(g)$ y $f_{2} \in O(h)$ $\Rightarrow$ $f_{1} + f_{2} \in O(max(g,h))$   
\newline
\newline
7. Regla del producto: Si $f_{1} \in O(g)$ y $f_{2} \in O(h)$ $\Rightarrow$ $f_{1} * f_{2} \in O(g * h)$ 
\newline
\newline
8. Si existe $\displaystyle \lim_{n \to \infty}$ $\displaystyle \frac{f(n)}{g(n)}$ $=$ $k$, según los valores que tome $k$:
\newline
\newline
a) Si $k \neq 0$ y $k < \infty$, entonces $O(f) = O(g)$  
\newline
\newline
b) Si $k = 0$, entonces $f \in O(g)$, es decir, $O(f) \subset O(g)$ pero sin embargo se verifica que $g \notin O(f)$. 
\newpage 

\subsubsection{Funciones de complejidad temporal}

Veamos algunas funciones de complejidad temporal. 
\newline
\newline
\textit{O(1)} \textbf{Complejidad constante}: Es independiente de los datos de entrada.
\newline
\newline
\textit{O(lg(n))} \textbf{Complejidad logarítmica}: Suele aparecer en determinados algoritmos con iteración o recursión (por ejemplo, búsqueda binaria). Todos los logaritmos, sea cual sea su base, son del mismo orden, por lo que se representan en cualquier base.
\newline
\newline
\textit{O(n)} \textbf{Complejidad lineal}: Suele aparecer en bucles simples cuando la complejidad de las operaciones internas es constante o en algunos algoritmos con recursión.
\newline
\newline
\textit{O(n lg(n))} En algunos algoritmos Divide \& Conquer (por ejemplo, Mergesort).
\newline
\newline
\textit{O($n^{2}$)} \textbf{Complejidad cuadrática}: Aparece en bucles o recursiones doblemente anidados.
\newline
\newline
\textit{O($n^{3}$)} \textbf{Complejidad cúbica}: En bucles o recursiones triples.
\newline
\newline
\textit{O($n^{k}$)} \textbf{Complejidad polinómica} ($k \geq 1$)
\newline
\newline
\textit{O($2^{n}$)} \textbf{Complejidad exponencial}: Suele aparecer en subprogramas recursivos que contengan dos o más llamadas internas.

\subsection{Cota inferior. Notación $\Omega$}

La notación $\Omega$ sirve para representar el límite o cota inferior del tiempo de ejecución de un algoritmo.
\newline
\newline
Más precisamente, la notación \textit{f $\in$ $\Omega(g)$} expresa que la función \textbf{\textit{f} está acotada inferiormente por alguna función proporcional a \textit{g}}.
\newline
\newline
En este caso, a \textit{g} se la llama cota inferior de \textit{f}.
\newline
\newline
Si para un algoritmo sabemos que $T_{peor} \in \Omega(g)$ se puede asegurar que para inputs de tamaño creciente, el tiempo será, en el peor caso, al menos proporcional a la cota.
\newline
\newline
La notación se usa tambien para dar cotas inferiores para problemas. A veces se puede decir para un problema que \textbf{para cualquier algoritmo que lo resuelva}, $T_{peor} \in \Omega(g)$, lo que significa que cualquier algoritmo que lo resuelva tiene una complejidad, en el peor caso, proporcional a la cota.
\newline
\newline
Veamos más formalmente la notación $\Omega$.
\newline
\newline
$f \in \Omega(g)$ significa que \textit{f} crece al menos como \textit{g}.  
\newline
\newline
$\Omega(g)$ = \{$f$ $|$ $\exists$ $n_{0}$, $k > 0$ tal que $n \geq n_{0}$ $\Rightarrow$ $f(n)$ $\geq$ $k$ · $g(n)$\} 

\subsubsection{Propiedades de $\Omega$}

A continuación, mencionamos algunas propiedades de la notación $\Omega$:
\newline
\newline
1. Para cualquier función $f$ se tiene que $f \in \Omega(f)$.
\newline
\newline
2. $f \in \Omega(f)$ $\Rightarrow$ $\Omega(f)$ $\subset$ $\Omega(g)$. 
\newline
\newline
3. $\Omega(f)$ $=$ $\Omega(g)$ $\Leftrightarrow$ $f \in \Omega(g)$ y $g \in \Omega(f)$
\newline
\newline
4. Si $f \in \Omega(g)$ y $g \in \Omega(h)$ $\Rightarrow$ $f \in \Omega(h)$.
\newline
\newline
5. Si $f \in \Omega(g)$ y $f \in \Omega(h)$ $\Rightarrow$ $f \in \Omega(max(g,h))$. 
\newline
\newline
6. Regla de la suma: Si $f_{1} \in \Omega(g)$ y $f_{2} \in \Omega(h)$ $\Rightarrow$ $f_{1} + f_{2} \in \Omega(g + h)$   
\newline
\newline
7. Regla del producto: Si $f_{1} \in \Omega(g)$ y $f_{2} \in \Omega(h)$ $\Rightarrow$ $f_{1} * f_{2} \in \Omega(g * h)$ 
\newline
\newline
8. Si existe $\displaystyle \lim_{n \to \infty}$ $\displaystyle \frac{f(n)}{g(n)}$ $=$ $k$, según los valores que tome $k$:
\newline
\newline
a) Si $k \neq 0$ y $k < \infty$, entonces $\Omega(f) = \Omega(g)$  
\newline
\newline
b) Si $k = 0$, entonces $g \in \Omega(f)$, es decir, $\Omega(g) \subset \Omega(f)$ pero sin embargo se verifica que $g \notin O(f)$. 

\subsection{Orden exacto. Notación $\Theta$}

Como última cota asintótica, definiremos los conjuntos de funciones que crecen asintóticamente de la misma forma
\newline
\newline
$\Theta(f)$ = $O(f)$ $\cap$ $\Omega(f)$
\newline
\newline
Intuitivamente, $t \in \Theta(f)$ indica que $t$ está acotada por $f$ tanto superior como inferiormente. 
\newline
\newline
Más precisamente, la notación \textit{f $\in$ $\Theta(g)$} expresa que la función \textit{f} crece (a partir de cierto momento) igual que \textit{g}.
\newline
\newline
Veamos más formalmente la notación $\Theta$.
\newline
\newline
$\Theta(g)$ = \{$f$ $|$ $\exists$ $n_{0}$, $k_{1},k_{2} > 0$ tal que $n \geq n_{0}$ $\Rightarrow$ $k_{1}$ · $g(n)$ $\leq$ $f(n)$ $\leq$ $k_{2}$ · $g(n)$\} 

\subsubsection{Propiedades de $\Theta$}

A continuación, mencionamos algunas propiedades de la notación $\Theta$:
\newline
\newline
1. Para cualquier función $f$ se tiene que $f \in \Theta(f)$.
\newline
\newline
2. $f \in \Theta(g)$ $\Rightarrow$ $\Theta(f)$ $=$ $\Theta(g)$. 
\newline
\newline
3. $\Theta(f)$ $=$ $\Theta(g)$ $\Leftrightarrow$ $f \in \Theta(g)$ y $g \in \Theta(f)$
\newline
\newline
4. Si $f \in \Theta(g)$ y $g \in \Theta(h)$ $\Rightarrow$ $f \in \Theta(h)$.
\newline
\newline
5. Si $f \in \Theta(g)$ y $f \in \Theta(h)$ $\Rightarrow$ $f \in \Theta(max(g,h))$. 
\newline
\newline
6. Regla de la suma: Si $f_{1} \in \Theta(g)$ y $f_{2} \in \Theta(h)$ $\Rightarrow$ $f_{1} + f_{2} \in \Theta(max(g + h))$   
\newline
\newline
7. Regla del producto: Si $f_{1} \in g + \Theta(g)$ y $f_{2} \in \Theta(h)$ $\Rightarrow$ $f_{1} * f_{2} \in \Theta(g * h)$ 
\newline
\newline
8. Si existe $\displaystyle \lim_{n \to \infty}$ $\displaystyle \frac{f(n)}{g(n)}$ $=$ $k$, según los valores que tome $k$:
\newline
\newline
a) Si $k \neq 0$ y $k < \infty$, entonces $\Theta(f) = \Theta(g)$  
\newline
\newline
b) Si $k = 0$, entonces $\Theta(g) \neq \Theta(f)$ porque ambas funciones no están creciendo al mismo ritmo o tasa.
\newpage

\section{Clase Teórica 04. Diseño de Tipos Abstractos de Datos}

Ahora, nos vamos a enfocar en el diseño jerárquico de TADs.
\newline
\newline
Entonces, ¿Qué significa diseñar?
\newline
\newline
Diseñar significa pasar de la descripción del \textbf{qué} del problema al \textbf{cómo}.
\newline
\newline
Queremos permitir un cambio de paradigma (del utilizado para especificar al utilizado para programar) que resulte ordenado, metódico, mas o menos formal.
\newline
\newline
\textbf{Ejemplo}
\newline
\newline
Consideremos el TAD \tadNombre{Conjunto}.
\newline
\newline
Veamos dos implementaciones posibles.
\newline
\newline
1. Un arreglo dimensionable donde:
\newline
\newline
\textbf{.} La inserción (sin repetidos) tiene un costo de $O(n)$ donde los elementos se colocan en su posición correspondiente, es decir, luego de la inserción, quedan ordenados.
\newline
\newline
\textbf{.} La búsqueda tiene un costo de $O(log(n))$ dado que se realiza aplicando búsqueda binaria.
\newline
\newline
2. Una secuencia donde:
\newline
\newline
\textbf{.} La inserción (sin repetidos) tiene un costo de $O(1)$ porque los elementos se colocan al final o al principio de la secuencia.
\newline
\newline
\textbf{.} La búsqueda tiene un costo de $O(n)$ dado que en el peor caso habrá que recorrer toda la secuencia.
\newline
\newline
¿Cuál estructura me conviene?
\newline
\newline
Depende del contexto de uso en el cual este usando la estructura de datos.
\newline
\newline
\textbf{La etapa de diseño} es una capa intermedia que nos va a permitir pasar de la especificación a la implementación del código.
\newline
\newline
Por lo tanto, en la etapa de diseño debemos:
\newline
\newline
\textbf{.} Proveer una \textbf{representación} para los valores
\newline
\newline
\textbf{.} Definir las \textbf{funciones} del tipo, es decir, proveer algoritmos para implementar las funciones del tipo. 
\newline
\newline
\textbf{.} Demostrar que eso es \textbf{correcto}.
\newline
\newline
¿Qué significa jerárquico?
\newline
\newline
Que pensaremos la resolución del \textit{cómo} a partir de representaciones de un tipo sobre otros separando responsabilidades en la construcción de la solución. 

\subsection{Contexto de uso}

¿Cómo discriminamos entre dos soluciones?
\newline
\newline
De acuerdo al contexto de uso, y los requerimientos de eficiencia.

\subsection{Metodología de diseño}

Desde un punto de vista abstracto, diseñar implica las siguientes tareas:
\newline
\newline
\textbf{.} Elección del TAD a diseñar siempre siguiendo una filosofía \textit{top-down}, es decir, comenzando siempre por el TAD más abarcativo.
\newline
\newline
\textbf{.} Introducción de los elementos no funcionales
\newline
\newline
\textbf{.} Vinculación entre la representación y su abstracción
\newline
\newline
\textbf{.} Iteración sobre los tipos restantes (filosofia \textit{top-down}).
\newline
\newline
Dentro de esta metodología, vamos a tener que enfocarnos en dos aspectos claves:
\newline
\newline
\textbf{.} Los \textbf{aspectos de la interfaz} de un tipo describen todo elemento relacionado con los aspectos de uso de dicho tipo, es decir, toda cuestión referida a lo que resulte visible desde afuera.
\newline
\newline
\textbf{.} Las \textbf{pautas de la implementación} serán todo aspecto que refiera a cuestiones vinculadas a los medios a través de los cuales el tipo garantiza esos aspectos de uso.
\newline
\newline
La definición de la \textbf{Interfaz} de un módulo de diseño implica tomar en cuenta de varias cosas y esencialmente debe explicarle al eventual usuario todos los aspectos relativos a los servicios que exporta:
\newline
\newline
\textbf{Servicios exportados}: desccribe para cada operación su complejidad, aspectos de aliasing, efectos colaterales sobre los argumentos, etc.
\newline
\newline
\textbf{Interfaz}: define en el paradigma imperativo las operaciones exportadas junto con su precondición y postcondición. Esto establecerá la relación entre la implementación de las operaciones y su especificación. 

\subsubsection{Transparencia referencial, aliasing, etc}

Una función es \textbf{referencialmente transparente} si su resultado solo depende de sus parámetros explicitos.
\newline
\newline
Por ejemplo:
\newline
\newline
\textbf{.} Si \textit{f(x) = \{return x+1\}}, $f(4)$  $+$ $f(3)$ es referencialmente transparente.
\newline
\newline
\textbf{.} Si \textit{f(x) = \{y = G*(x+1); G++; return y\}}, no es referencialmente transparente porque no conocemos el valor de la variable global $G$.
\newline
\newline
\textbf{Aliasing} significa la posibilidad de tener más de un nombre para la misma cosa. En concreto, dos punteros o referencias hacia el mismo objeto.
\newline
\newline
Veamos el siguiente ejemplo:
\newline
\newline
Una operación que dado un arbol binario (no vacio) nos devolviera dos árboles y un elemento (subarbol izquierdo, derecho y raiz).
\newline
\newline
\TipoVariable{Podar(in A: ab(elem), out I: ab(elem), out r: elem, out D: ab(elem))}
\newline
\newline
Implementación 1: armar copias de los subarboles izquierdo y derecho de A, devolverlas como I y D.
\newline
\newline
Implementación 2 (más rápida): devolver en I y D referencias a los subárboles de A.
\newline
\newline
En este último caso, estariamos provocando \textit{aliasing} entre los árboles, porque cualquier modificación que se realice sobre I o D, luego de ejecutar la operación Podar, repercutirá en A.
\newpage
\subsection{Ejemplo con Conj(NAT)}

Nos solicitan el siguiente contexto de uso:
\newline
\newline
\textbf{.} La obtención del minimo debe tener complejidad $O(1)$.
\newline
\newline
\textbf{.} Quitar un elemento debe tener complejidad $O(n)$, siendo $n$ la cantidad de elementos agregados.
\newline
\newline
\textbf{.} Agregar un elemento debe tener complejidad $O(1)$.
\newline
\newline
\textbf{Servicios exportados:}
\newline
\newline
\textbf{.} pertenece: No produce aliasing ni efectos colaterales sobre los argumentos, posee orden de complejidad temporal $O(n)$ con $n$ la cantidad de elementos agregados al conjuntos.
\newline
\newline
\textbf{.} vacio: No produce aliasing ni efectos colaterales, posee orden de complejidad temporal $O(1)$. 
\newline
\newline
\textbf{.} agregar: No produce aliasing, modifica colateralmente el conjunto argumento, posee orden de complejidad temporal $O(1)$. 
\newline
\newline
\textbf{.} quitar: No produce aliasing sobre los argumentos, modifica colateralmente el conjunto argumento, posee orden de complejidad temporal $O(n)$ con $n$ la cantidad de elementoss agregados al conjunto.
\newline
\newline
\textbf{.} vacio?: No produce aliasing ni efectos colaterales, posee orden de complejidad temporal $O(1)$.  
\newline
\newline
\textbf{.} mínimo: No produce aliasing ni efectos colaterales, posee orden de complejidad temporal $O(1)$.
\newline
\newline
\textbf{FALTARIA COMPLETAR LA INTERFAZ!!!}
\newpage

\subsection{La Representación}

La definición de la \textbf{representación} de un módulo de diseño implica tomar cuenta todo aspecto referido a cómo se satisfacen los requerimientos declarados en la interfaz.
\newline
\newline
\textbf{. Estructura}: Describe la estructura interna sobre la cual las operaciones aplican.
\newline
\newline
\textbf{. Relación entre la representación y la abstracción}: Por un lado, expone toda restricción sobre la estructura de representación a fin de que efectivamente pueda ser considerada una implementación de un valor del tipo al que implementa; y por otro lado, vincula los valores con su contraparte abstracta, es decir, con algún término de la especificación a quien este represente.
\newline
\newline
\textbf{. Algoritmos}: Mostrar como se realizan los algoritmos para implementar las funciones correspondientes al TAD incluyendo tanto las operaciones exportadas como las auxiliares junto con su cálculo detallado que justifica su complejidad. 
\newline
\newline
\textbf{. Servicios usados:} Declara toda demanda de complejidad, aliasing o efecto colateral que los servicios usados de otros tipos en la programación de los algoritmos deban satisfacer. 

\subsubsection{Estructura de representación}

La estructura de representación describe los valores sobre los cuales se representará el género que se está implementando.
\newline
\newline
Veamos esto con un ejemplo.
\newline
\newline
Queremos implementar un conjunto de naturales con el siguiente contexto: los números del 1 al 100 deben manejarse en $O(1)$ porque se usan mucho. El resto, en $O(n)$. Rápidamente debo conocer la cardinalidad.
\newline
\newline
Proponemos la siguiente estructura:
\newline
\newline
\textbf{.} Un arreglo de 100 posiciones booleanas donde haya 1 en la posición $i$ si el elemento $i$ pertenece al conjunto. De esta forma, con acceder a la posición correspondiente al número, se verifica si pertenece o no al conjunto. 
\newline
\newline
\textbf{.} Una secuencia que incluye todos los elementos mayores a 100.
\newline
\newline
\textbf{.} Un nat para la cardinalidad.
\newline
\newline
Luego, escribimos esta estructura de representación como:
\begin{Estructura}{conj\_semi\_rapido}[estr]
	\begin{Tupla}[estr]%
		\tupItem{rapido}{arreglo [1,...,100] de nat}%
		\tupItem{resto}{secu(nat)}%
		\tupItem{cardinal}{nat}%
	\end{Tupla}
\end{Estructura}
\medskip
\medskip
\subsubsection{El invariante de representación}

¿Cualquier instancia es válida?
\newline
\newline
¿$\langle$[0,...,0], $\secuvacia$, 8254$\rangle$ es un \TipoVariable{conj\_semi\_rapido} válido? No, porque 8254 representa la cardinal del conjunto y como el arreglo correspondiente a los numeros del 1 al 100 se encuentra completo de 0s, su cardinalidad es 0 y los números mayores a 100 están representados por una secuencia vacia, no hay ningún número mayor a 100 que pertenezca al conjunto. Por lo tanto, la cardinalidad del conjunto es 0 + 0 = 0 != 8254.
\newline
\newline
¿$\langle$[0,...,0], $\langle$37,107,28$\rangle$, 3$\rangle$ es un \TipoVariable{conj\_semi\_rapido} válido? No, porque a pesar de que el arreglo de número del 1 a 100 tiene cardinalidad 0 porque está lleno de 0s y la secuencia de números mayores a 100 tiene 3 elementos tanto el 37 como el 28 no son mayores a 100.
\newpage
¿Para que nos sirve separar con facilidad instancias válidas de invalidas?
\newline
\newline
\textbf{.} Como una forma de documentar la estructura.
\newline
\newline
\textbf{.} Como condición necesaria para establecer una relación con la abstracción.
\newline
\newline
\textbf{.} Para agregar a las postcondiciones, como una forma de garantizar que nuestros algoritmo no rompen la estructura.
\newline
\newline
\textbf{.} Para agregar a las precondiciones, como una garantia con la que cuentan nuestros algoritmos.
\newline
\newline
\textbf{.} Como una guia a la hora de escribir los algoritmos porque deben valer tanto en la precondición como en la postcondición
\newline
\newline
\textbf{.} Si pudiésemos programar el chequeo, como una forma adicional de detectar instancias corruptas.
\newline
\newline
El \textbf{invariante de representación} es una función booleana con dominio en el género de representación que da $true$ cuando recibe una instancia válida.
\newline
\newline
Si representamos $T_{1}$ sobre $T_{2}$:
\newline
\Rep[$T_{2}$][t]{... condiciones que garanticen que $t$ representa una instancia válida de $T_{1}$...}
\medskip
\medskip
Volviendo al ejemplo, las condiciones del invariante de representación, descriptas de manera informal, deberían ser las siguientes:
\newline
\newline
1) Que $resto$ solo tenga números mayores que 100.
\newline
\newline
2) Que $resto$ no tenga números repetidos.
\newline
\newline
3) Que $cardinal$ tenga la longitud de resto más la cantidad de celdas de \textit{rápido} que esten en 1 ($true$).
\newline
\newline
Veamos la descripcion formal del invariante de representación: 
\newline
\Rep[estr][e]{(1) ($\forall n$:nat) (está?($n,e.resto$) $\impluego$ $n > 100$) $\yluego$ (2) ($\forall n$:nat) (cant\_apariciones($n,e.resto$) $\leq$ $1$) $\yluego$ \newline (3) $e.cant$ $=$ $long(e.resto)$ $+$ cant\_trues($e.rapido$)}
\medskip
\medskip
\medskip
donde \textit{está}, $cant\_de\_apariciones$ y $long$ son funciones de secuencias, y $contar\_trues$ es una función sobre arreglos. En los problemas más complicados se vuelve muy importante analizar metódicamente la estructura de representación a la hora de elegir los predicados del invariante. Una forma de organizarse es empezar mirando cada campo de la estructura de forma individual, para ver bien que condiciones tienen que cumplir. Una vez analizado esto, podemos ver la relación que deben tener los distintos campos entre si para que su información sea consistente.
\newline
\newline
\textbf{Función de abstracción}
\newline
\newline
La función de abstracción es una herramienta que permite vincular una estructura con \textbf{algún} valor abstracto al que representa ¿Cómo les parece que esto puede hacerse? Es decir, ¿Qué debemos usar para caracterizar algún término abstracto que representa una estructura particular?
\newline
\newline
$Abs$: $T_{2}$ $e$ $\rightarrow$ $T_{1}$ (Rep($e$))
\newline
\newline
Por lo tanto, la función de abstracción tiene como dominio al conjunto de instancias que son la imagen abstracta del tipo al que representa (y verifican el invariante de representación) y devuelve una imagen abstracta de la instancia del tipo representado, es decir, aquella instancia que queremos representar.
\newline
\newline
La manera en la que se caracteriza un término es o bien a través de los generadores o de los observadores. Normalmente el uso de los observadores resulta más sencillo.
\newpage
Anteriormente, habiamos afirmado que \TipoVariable{conjuntoDeNat} \textbf{se representa con} \TipoVariable{$\langle$secuenciaDeNat, nat$\rangle$} 
\newline
\newline
Ahora, la función de abstracción viene a cumplir la vuelta de esto, es decir, si tengo \TipoVariable{$\langle$secu[nat], nat$\rangle$} y le aplico la función de abstracción, vuelvo al \TipoVariable{conj[nat]}, es decir, \TipoVariable{$\langle$secu[nat], nat$\rangle$} \textbf{representa a (abs)} al  \TipoVariable{conj[nat]}.
\newline
\newline
Volviendo al ejemplo del \TipoVariable{conjunto\_semi\_rapido}, esccribimos su función de abstracción:
\newline
\AbsFc[estr]{conjunto\_semi\_rapido $C$}[e]{ $C$ / ($\forall n$:nat) ($n$ $\in$ $C$ $\impluego$ ($n \geq 100$ $\yluego$ $r.rapido[n]$) $\lor$ ($n > 100$ $\yluego$ esta?($n,e.resto$)))}
\medskip
\medskip
\textbf{Propiedades}
\newline
\newline
\textbf{.} Una vez restringida a ($Rep(e)$), la función de abstracción debe ser total.
\newline
\newline
\textbf{.} No tiene por qué ser inyectiva. Dos estructuras diferentes pueden representar al mismo término de un TAD. Veamos el siguiente ejemplo:
\newline
\newline
\TipoVariable{Abs: secu(nat) $s$ $\rightarrow$ conj(nat)}
\newline
\newline
\TipoVariable{Abs(1 $\puntito$ 2 $\puntito$ 3 $\puntito$ $\secuvacia$)} $\igobs$ \{1,2,3\} $\igobs$ \TipoVariable{Abs(3 $\puntito$ 1 $\puntito$ 2 $\puntito$ $\secuvacia$)}
\newline
\newline
\textbf{.} Debe ser suryectiva sobre las clases de equivalencia determinadas por la igualdad observacional, restringidas a lo especificado por el contexto de uso.
\newline
\newline
\textbf{.} No tiene por qué ser suryectiva sobre todos los términos del género representado. Es decir, no podemos asegurar que todo término del TAD va a ser imagen de la función de abstracción para la estructura de representación que estemos utilizando.  

\subsubsection{Los algoritmos}

Recordemos la interfaz de \tadNombre{Agregar(...)}:
\newline
\newline
\InterfazFuncion{Agregar}{\Inout{C}{conjunto\_semi\_rapido}, \In{e}{nat}}{}%
[$C$ $\igobs$ $C_{0}$ $\land$ $e \notin C$]
{$C$ $\igobs$ $Ag(C_{0},e)$}%
\newline
\newline
Luego, una posible implementacion del algoritmo podria ser la siguiente:

\begin{algorithm}[H]{i\tadNombre{Agregar}(\Inout{C}{estr}, \In{e}{nat})}
	\begin{algorithmic}[1]
		\State $C.cant++$                      
		\If{$e < 100$}
		\State $C.rapido[e]$ $=$ $true$                      
		\Else
		\State AgregarAtras($C.resto,e$)                     
		\EndIf
		
		\medskip
	\end{algorithmic}
\end{algorithm}
\newpage
\textbf{Probando corrección}
\newline
\newline
Veamos una funcionalidad adicional que tiene la función de abstracción.
\newline
\newline
Veamoslo con un ejemplo para Conjunto implementado sobre secuencia.
\newline
\newline
Dada una secuencia $s$, el resultado de la operación agregar un natural $n$ sobre la abstracción de la secuencia $Ag(Abs(s),n)$ debe ser observacionalmente equivalente a agregar el natural a la abstracción de esa agregación, es decir, $Ag(Abs(s),n)$ $\igobs$ $Abs(s \circulito n)$
\newline
\newline
De forma más general, queremos decir que la función de abstracción debe ser un homomorfismo respecto de la signatura del TAD, o sea, que para toda operación $\puntito$, $Abs(i \puntito (p_{1},...,p_{n}))$ $\igobs$ $\puntito$($Abs(p_{1})$,...,$Abs(p_{n})$) 
\newline
\newline
Es decir, que la abstracción de la implementación de una operación $\puntito$ tiene que ser observacionalmente equivalente a la implementación de la abstracción de esa operación.  
\newpage
