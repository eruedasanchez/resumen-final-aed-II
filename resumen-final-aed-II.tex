\documentclass[10pt,a4paper]{article}
\usepackage[paper=a4paper,hmargin=0.5cm,bottom=1.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{xargs}
\usepackage{xspace}
\usepackage{caratula}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef,aed2-diseno}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage{graphicx}
\usepackage{graphicx} 
\graphicspath{ {./images/} }
\usepackage[rightcaption]{sidecap}
\usepackage{wrapfig}

\materia{Algoritmos y Estructuras de Datos II}
\titulo{Apunte examen final}
\subtitulo{Segundo cuatrimestre 2021}
\integrante{Ezequiel Rueda Sanchez}{522/16}{ezequiel.ruedasanchez@gmail.com}

%  ü, é, á, í, ó, ú, ñ, Ñ%


\begin{document}

\maketitle

\section{Clase Teórica 01. Especificación I}

\subsection{Introducción}

Típicamente, nos enfrentamos a la siguiente situación. Tenemos un $problema$ que no es presentado en una manera difusa, vaga y se pretende que lo podamos resolver a traves de una computadora de forma eficiente. Lo problematico es transitar este recorrido que va desde la definición informal del problema a su resolución computacional. Este camino tiene una serie de pasos que los llamamos \textbf{especificación}, \textbf{diseño} e \textbf{implementación}. 

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.7\textwidth]{etapas-res-problem}
%	\caption{Etapas en la resolucion de un problema}
%	\label{drivers1}
%\end{figure}

\subsection{Contexto}

Un \textbf{algoritmo} es un procedimiento para resolver un problema, descripto por una secuencia ordenada y finita de pasos bien determinados que nos llevan de un estado inicial a uno final.
\newline
\newline
Ahora bien, el algoritmo, más alla de ser un objeto en si mismo, es una herramienta para resolver problemas donde los más complejos se van a resolver combinando parte de ellos y se van a poder modificar para resolver distintas variantes o \textbf{problemas genéricos}.   
\newline
\newline
Entonces, ¿Qué es resolver un problema \textit{genérico}?
\newline
\newline
Se trata de, dada su descripción, proponer un algoritmo que resuelva cualquier instancia del mismo. Por ejemplo, no proponer un algoritmo que resuelva la suma de 7 y 5 sino proponer un algoritmo que resuelva la suma de dos números enteros cualesquiera.  
\newline
\newline
Para ello, necesitamos herramientas que nos ayuden a transitar el camino desde el enunciado informal hasta la implementación en la computadora. Sobre ello vamos a trabajar a lo largo del curso.

\subsection{Resolución de problemas}

El dueño de un restaurant quiere asegurarse de que los pedidos sean atendidos con prolijidad. Los mozos llevan los pedidos hasta la cocina donde los colocan. Cuando el cocinero se libera, saca el primer pedido y prepara el plato indicado. El dueño quiere saber cuál es el próximo plato a preparar, cuántos pedidos atiende el cocinero cada día y cuál fue el día con menos pedidos.
\newline
\newline
No parece que el problema se pueda expresar directamente en un lenguaje matemático, pero está claro que necesitamos algo riguroso y formal para poder pasar al algoritmo. 
\newline
\newline
Sin embargo, podemos observar que se pretenden obtener resultados de varios tipos distintos: al menos naturales (los dias que pasan) y platos. Además, hay varias operaciones asociadas a estos tipos.
\newline
\newline
Para poder modelar este problema, vamos a usar una herramienta nueva: \textbf{Tipos Abstracto de Datos (TAD)}. Veamos un poco más en detalle este concepto.
\newline
\newline
\textbf{.} Tipo: conjunto de valores asociados a operaciones
\newline
\newline
\textbf{.} Tipo abstracto: no nos interesa tanto "la forma" de los valores sino saber que operaciones podemos realizar sobre ellos donde la única manera de obtener información sobre ellos es a través de las operaciones que definan.
\newline
\newline
El problema maneja platos, dias y (al menos un) restaurant.
\newline
\newline
¿Qué nos interesa saber de cada una de estas $"$cosas$"$?
\newline
\newline
\textbf{.} Los dias pasan por lo que vamos a querer contarlos.
\newline
\newline
\textbf{.} Solo nos interesa poder diferenciar los platos entre si.
\newline
\newline
\textbf{.} De los restaurants, varias cosas, asi que lo dejamos de lado por un momento.
\newpage
Comenzamos usando renombres:
\newline
\newline
\textbf{.} TAD \tadNombre{DIA} es \tadNombre{NAT}  
\newline
\newline
\textbf{.} TAD \tadNombre{PLATO} es \tadNombre{STRING}.
\newline
\newline
¿Por qué tenemos que renombrar estos TADs y no utilizar STRING o NAT directamente? Lo que queriamos hacer era utilizar un lenguaje de especificación que nos permita abstraer ciertos conceptos, por lo que usar STRING directamente no sería correcto. Para el restaurant no tiene sentido un STRING, pero los PLATOS si. De esta manera, nos alejamos de la manera en la que representamos los datos en una computadora y nos acercamos a la definición del problema.
\newline
\newline
Pasemos ahora al restaurant...
\newline
\begin{tad}{\tadNombre{Restaurant}}
	\medskip	
	\textbf{generos} restaurant
	\newline
	
	\textbf{operaciones}
	\medskip
	\tadOperacion{inaugurar}{}{restaurant}{}
	\medskip
	\tadOperacion{cantPlatosPendientes}{restaurant}{nat}{}
	\medskip
	\tadOperacion{proximoPedido}{restaurant/r}{plato}{cantPlatosPendientes($r$) $>$ 0}
	\medskip
	\tadOperacion{prepararPlato}{restaurant/r}{restaurant}{cantPlatosPendientes($r$) $>$ 0}
	\medskip
	\tadOperacion{tomarPedido}{restaurant, plato}{restaurant}{}
	\medskip
	\tadOperacion{nuevoDia}{restaurant}{restaurant}{}
	\medskip
	\tadOperacion{diaActual}{restaurant}{dia}{}
	\medskip
	\tadOperacion{platosPorDia}{restaurant/r, dia/d}{nat}{$d$ $\leq$ diaActual($r$)}
	\medskip
	\tadOperacion{diaMenosPedidos}{restaurant}{dia}{}
	\medskip
\end{tad}
\medskip
A esto lo llamamos \textbf{signatura} del TAD. La signatura nos indica que operaciones tiene el tipo, con qué parámetros y qué devuelven.
\newline
\newline
Las operaciones de los TAD's son \textit{funciones totales}. O sea, funciones que están definidas para cada valor del dominio. Por eso, en casos como \TipoVariable{preparar\_plato()} debemos restringir el dominio.
\newline
\newline
Ahora, necesitamos darle \textbf{semántica}, es decir, comportamiento a las operaciones. En los TADs usaremos para eso los \textbf{axiomas}.
\newline
\newline
Entonces, veamos los axiomas del TAD \tadNombre{RESTAURANT}.
\newline
\begin{tad}{\tadNombre{Restaurant}}
\medskip
\tadAxiomas[$\forall$ $r$ : \tadNombre{Restaurant}, $p$ : \tadNombre{Plato}, $d$ : \tadNombre{Dia}]
\medskip
\tadAlinearAxiomas{diaActual(tomarPedido(r,p))}
\medskip
\tadAxioma{diaActual(inaugurar())}{0}
\medskip
\tadAxioma{diaActual(nuevoDia(r))}{diaActual(r)+1}
\medskip
\tadAxioma{diaActual(tomarPedido(r,p))}{diaActual(r)}
\medskip
\medskip

\tadAlinearAxiomas{cantPlatosPendientes(tomarPedido(r,p))}
\medskip
\tadAxioma{cantPlatosPendientes(inaugurar())}{0}
\medskip
\tadAxioma{cantPlatosPendientes(tomarPedido(r,p))}{cantPlatosPendientes(r)+1}
\medskip
\tadAxioma{cantPlatosPendientes(prepararPlato(r))}{cantPlatosPendientes(r)-1}
\medskip
\medskip

\tadAlinearAxiomas{cantPlatosPendientes(tomarPedido(r,p))}
\medskip
\tadAxioma{proximoPedido(r)}{ult(secuenciaDePedidos(r))}
\medskip
\medskip

\tadAlinearAxiomas{secuenciaDePedidos(tomarPedido(r,p))}
\medskip
\tadAxioma{secuenciaDePedidos(inaugurar())}{$\secuvacia$}
\medskip
\tadAxioma{secuenciaDePedidos(tomarPedido(r,p))}{p $\puntito$ secuenciaDePedidos(r)}
\medskip
\tadAxioma{secuenciaDePedidos(prepararPlato(r))}{com(secuenciaDePedidos(r))}
\medskip
\medskip

\tadAlinearAxiomas{platosPorDia(d, tomarPedido(r,p))}
\medskip
\tadAxioma{platosPorDia(d, inaugurar())}{0}
\medskip
\tadAxioma{platosPorDia(d, tomarPedido(r,p))}{platosPorDia(d,r)}
\medskip
\tadAxioma{platosPorDia(d, prepararPlato(r))}{\IF diaActual(r) = d THEN platosPorDia(d,r)+1 ELSE platosPorDia(d,r) FI}
\medskip
\tadAxioma{platosPorDia(d, nuevoDia(r))}{\IF diaActual(r)+1 = d THEN 0 ELSE platosPorDia(d,r) FI}
\medskip
\medskip

Por ultimo, vamos a axiomatizar la funcion diaMenosPedidos(r) de la siguiente forma:
\newline
\newline
($\forall$ $d'$:dia) (0 $\leq$ $d'$ $\leq$ diaActual($r$) $\impluego$ platosPorDia($r$, diaMenosPedidos($r$)) $\leq$ platosPorDia($r,d'$))
\medskip
\end{tad}

\subsection{TAD's}

¿Qué es un TAD?
\newline
\newline
\textbf{.} Desde el punto de vista formal, es una herramienta lógico/matematica. Eso es bueno porque nos da la rigurosidad que necesitamos para entender claramente qué hay que hacer.
\newline
\newline
\textbf{.} Desde el punto de vista práctico, es una herramienta poderosa y flexible que nos permite resolver o formalizar infinidad de problemas.
\newline
\newline
\textbf{.} Desde el punto de vista histórico, uno de los primeros intentos por abordar este problema.
\newline
\newline
Una de las ventajas de la teoría de los tipos abstractos de datos es que no requiere de tipos primitivos que deban definirse por fuera de la misma. 

\subsection{Secciones de un TAD}

Las secciones de un TAD son:
\newline
\newline
\textbf{.} Géneros: Los géneros (en general va a haber sólo uno, pero podrían ser más) son el nombre que recibe el conjunto de valores del tipo. Pensar en el monoide conmutativo ($\mathbb{N}$, +) y en el conjunto de los números naturales $\mathbb{N}$. 
\newline
\newline
\textbf{.} Usa: Inclusión de los géneros y operaciones definidos en otros tipos abstractos de datos que utiliza el tipo que estamos definiendo.
\newline
\newline
\textbf{.} Exporta: Qué operaciones y géneros se dejan a disposición de los usuarios del tipo.
\newline
\newline
\textbf{.} Generadores: Son operaciones que permiten construir instancias del tipo. Un conjunto de generadores está bien definido si una combinación de ellos permite construir cualquier instancia posible del tipo.
\newline
\newline
\textbf{.} Observadores: Son operaciones que nos permiten, utilizadas en conjunto, diferenciar instancias del tipo.
\newline
\newline
\textbf{.} Axiomas: Son las reglas que nos explican el comportamiento de las funciones o describen el comportamiento desde el punto de vista semántico de un objeto del TAD. 
\newpage

\section{Clase Teórica 02. Especificación II}

\subsection{Introducción}

La especificación con TADs no es la única forma de hacerlo.
\newline
\newline
Siempre es posible la utilización de \textit{métodos informales}
\newline
\newline
Los métodos informales tienen un menor costo inicial (son mas fáciles de construir y utilizar) pero justamente por ello, no permiten encontrar errores e inconsistencias en la especificación, ni la aplicación de técnicas automáticas para la validación (en contraposición a los métodos formales con la inducción estructural por ejemplo), etc.
\newline
\newline
El costo de reparar un defecto aumenta con el tiempo entre la introducción y el descubrimiento.
\newline
\newline
En cambio, los \textit{métodos formales} no cuentan con esos problemas pero existen de variado tipo y color con ventajas y desventajas para cada caso. Veamos alguno de ellos:
\newline
\newline
\textbf{.} Algebraicos: el sistema se especifica mediante la definición de un álgebra con sus términos, operaciones, axiomas, etc. Los TADs entran en esta categoría.
\newline
\newline
\textbf{.} Operacionales: la especificación se realiza en un lenguaje imperativo de alto nivel.
\newline
\newline
\textbf{.} Basados en estados: el sistema se modela como un conjunto de estados posibles y las relaciones entre ellos. 

\subsection{Resolución de problemas}

Retomando el ejercicio del \textit{restaurant}, comenzamos con una descripción del problema y terminamos con el modelao del mismo. 
\newline
\newline
Pero, ¿Qué ocurrió en el medio?
\newline
\newline
¿Qué pasó con, por ejemplo, el dueño del restaurant? 
\newline
\newline
El dueño no está porque no es necesario que esté. Utilizamos un proceso llamado \textbf{abstracción}. La abstracción consiste en identificar los aspectos importantes de un fenomeno e ignorar el resto de los detalles.
\newline
\newline
También utilizamos otro concepto: el de \textbf{modularidad}. Los TADs se incluyen de manera tal que no sea necesario (ni conveniente) escribir una gran especificación que mezcle todo y dificulte la comprensión. 
\newline
\newline
El restaurant que especificamos, ¿es eficiente?
\newline
\newline
La pregunta no tiene sentido en una etapa de especificación porque justamente la especificación define que es lo que tenemos que computar, que es lo que tenemos que calcular para resolver nuestro problema y no como lo vamos a hacer. 
\newline
\newline
Nos interesa describir el \textbf{el qué} y no \textbf{el cómo}.

\subsection{Axiomatización}

Las operaciones son funciones, asi que debemos evitar inconsistencias. Para lograr esto, evitaremos la \textbf{sobre especificación}. Es decir, cuando tenemos varias formas de decir lo mismo.
\newline
\newline
Veamos la \textit{sobre especificación} con un ejemplo.
\newline
\newline
\textbf{.} \TipoVariable{prim\_excepto\_3(3 $\puntito$ S)} $\equiv$ 21
\newline
\newline
\textbf{.} \TipoVariable{prim\_excepto\_3(a $\puntito$ S)} $\equiv$ a
\newline
\newline
En este ejemplo, quiero devolver el primer elemento de la secuencia \TipoVariable{S} excepto que cuando el primer elemento es un 3, devuelvo cualquier número arbitrario, por ejemplo, el 21. 
\newline
\newline
Observemos que estamos haciendo una especie de \textit{pattern matching} porque si la secuencia comienza con 3, elijo la primer opción y en cualquier otro caso, la segunda. Pero tenemos valores contradictorios en el caso que el primer elemento de la secuencia sea el 3 porque nada nos asegura que vaya por la primer o segunda opción.
\newline
\newline
Tampoco podemos especificar sobre los casos restringidos ya que están fuera del dominio.
\newline
\newline
No debemos \textbf{subespecificar}. Es decir, dejar de lado y no dar definiciones precisas de ciertos aspectos particulares de un determinado axioma. Veamos el siguiente ejemplo.
\newline
\tadOperacion{premiar}{torneo/t, jugador/j}{premio}{}
\medskip
\tadAlinearAxiomas{premiar(t,j)}
\medskip
\tadAxioma{premiar(t,j)}{seleccionarMejorPremio(premiosDisponibles(t))}
\medskip
\tadAxioma{premiar(t,j)}{dameUno(premiosDisponibles(t))}
\medskip
\medskip
Observemos que la segunda axiomatización es mucho más debil (está \textit{subespecificada}) que la primera dado que ésta es mucho mas precisa porque pide el mejor premio mientras que la segunda simplemente devuelve un premio. 
\newline
\newline
Entonces, ¿Hasta cuánto debemos axiomatizar?
\newline
\newline
Una regla práctica consiste en axiomatizar todos los observadores básicos sobre todos los generadores no restringidos, para asegurar que cubrimos todo el dominio.
\newline
\newline
En general, aunque podría haber excepciones, el resto de las operaciones deberían poder escribirse en base a los observadores básicos.

\subsection{Algunas libertades}

Si usamos todo lo que aparece mencionado, no es necesario escribir la clausula \textbf{usa}.
\newline
\newline
El \textbf{exporta} tiene un valor por omisión: los géneros, los observadores básicos y los generadores. Además, cuando se exporta algo más, alcanza con aclarar qué es lo extra que se exporta.
\newline
\newline
En la \textbf{axiomatización}:
\newline
\newline
\textbf{.} Todas las variables libres se suponen universalmente cuantificadas.
\newline
\newline
\textbf{.} Sólo cuantificamos explícitamente cuando podría generarse confusión.

\subsection{Elección de generadores y observadores}

Conviene que el conjunto de observadores y generadores sean \textit{minimales}. 
\newline
\newline
Si los generadores no lo fuesen, se corre el riesgo de producir inconsistencias.
\newline
\newline
Idem con los observadores. Además, la redundancia atenta contra la claridad.
\newline
\newline
Los lenguajes naturales tienen una \textit{semántica difusa} mientras que los \textit{lenguajes formales} de especificación son rigurosos, o dicho de otra manera, tienen una \textit{semántica precisa}. A esta diferencia se la conoce como \textbf{semantic gap} o \textbf{brecha semántica}.
\newline
\newline
Como primer paso para vincular los mundos \textit{informales} con los \textit{formales} utilizaremos una herramienta llamada \textbf{igualdad observacional}.
\newpage

\subsection{Igualdad observacional (como herramienta)}

La igualdad observacional es un predicado entre instancias del tipo que nos dice cuando son iguales (desde el punto de vista de su comportamiento).
\newline
\newline
Notemos que \TipoVariable{Ag(1, Ag(2, $\emptyset$))} es sintácticamente distinto a \TipoVariable{Ag(2, Ag(1, $\emptyset$))} aunque desde el punto de vista de comportamiento nos gustaría que sean iguales. 
\newline
\newline
Entonces, para poder comparar las instancias del ejemplo anterior vamos a utilizar la igualdad observacional que se va a valer de una serie de funciones (los observadores básicos) los cuales van a prestar atención a detalles particulares de esas instancias para poder compararlas.
\newline
\newline
Por lo tanto, la igualdad observacional nos permite:
\newline
\newline
\textbf{.} Deducir cuáles son los observadores necesarios.
\newline
\newline
\textbf{.} Explicitar cómo se combinan en un único predicado.

\subsection{Congruencia}

Imaginemos el TAD \tadNombre{Negocio}.
\newline
\begin{tad}{\tadNombre{Negocio}}
	\medskip	
        \textbf{generadores}
	\medskip
	\tadOperacion{inaugurar}{}{negocio}{}
	\medskip
	\tadOperacion{vender}{negocio, producto}{negocio}{}
	\medskip
        \medskip
        \textbf{observadores basicos}
        \medskip
	\tadOperacion{total\_vendido}{negocio}{nat}{}
	\medskip
        \medskip
        \textbf{otras operaciones}
        \medskip
\tadOperacion{ventas}{negocio}{secu(producto)}{}
	\medskip
\end{tad}
\medskip
\medskip
De acuerdo con esa especificación dos negocios van a ser iguales si su total vendido coincide. Sin embargo, podría haber instancias cuyo total vendido coincida pero la secuencia de productos que devuelve la operación ventas no.
\newline
\newline
Formalmente, la función \TipoVariable{ventas()} rompe la \textbf{congruencia}. Es decir, diferencia elementos que quedan en la misma clase de equivalencia de acuerdo con la igualdad observacional (o lo que es lo mismo, de acuerdo con los observadores básicos).
\newline
\newline
Desde el punto de vista de modelado, o bien desaparece \TipoVariable{ventas()} o bien se vuelve un observador básico, y por ende, miembro de la igualdad observacional.
\newline
\newline
Si no hacemos eso, se genera una \textbf{inconsistencia}: hay dos instancias del TAD \tadNombre{Negocio} que son equivalentes según los observadores básicos, pero que son diferenciables de acuerdo a los axiomas efectivamente escritos. 
\newpage
